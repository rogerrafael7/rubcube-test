import { Injectable } from '@nestjs/common';
import { environment } from '../../environment';
import { readdir, readFile } from 'fs/promises';
import { resolve } from 'path';
import { Model } from 'mongoose';
import { Log } from '../../database/log.schema';
import { InjectModel } from '@nestjs/mongoose';

@Injectable()
export class JobService {
  constructor(
    @InjectModel(Log.name)
    readonly logModel: Model<Log>,
  ) {}
  async reProcessAll() {
    const logsFileName = (await readdir(environment.DATA_LOGS_PATH)).filter(
      (f) => /.txt$/.test(f),
    );

    await this.logModel.deleteMany({});

    for (const filename of logsFileName) {
      const filepath = resolve(environment.DATA_LOGS_PATH, filename);
      await this.parseLogFile(filepath);
    }
  }
  private async parseLogFile(filepath: string) {
    const contentTxt = await readFile(filepath, 'utf-8');
    const initialAllLinesRegex = /[\d:]{4}\s+([\w\s]+):(.+)/;
    const initialGameRegex = /InitGame:\s+(.*)$/;
    const killRegex = /Kill:\s+[^:]+:\s+(.+)killed\s+(.+)\s+by\s+(MOD_.+)/;

    let countChangeGameConfig = 0;

    const lines = contentTxt.split('\n');
    for (const [index, l] of Object.entries(lines)) {
      const line = l.trim();
      const match = line.match(initialAllLinesRegex);
      if (!match) continue;
      const row = new Log();
      row.logLineNum = Number(index) + 1;
      row.eventType = match[1];
      row.eventValue = match[2];

      const initialGameMatch = line.match(initialGameRegex);
      const killMatch = line.match(killRegex);
      if (initialGameMatch) {
        countChangeGameConfig += 1;
      } else if (killMatch) {
        row.killerName = killMatch[1];
        row.killedName = killMatch[2];
        row.killModType = killMatch[3];
      }

      await new this.logModel({
        ...row,
        gameNameAutoGenerated: `Game_${countChangeGameConfig}`,
      }).save();
    }
  }
}
